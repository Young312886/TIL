## Queue
### 특성
- 스택과 마찬가지로 삽입과 삭제가 제헌적인 자료구조
- LIFO 형식으로 선입 선출이 이뤄지게 된다.
- 들어오는 인덱스와 나가는 인덱스가 따로 관리되게 된다.
- Front가 출력 될 위치이며, Rear가 저장 될 위치 이다.
- 삽입 = enQueue / 삭제 = deQueue / 큐 생성 = createQueue / 하나 반환 = Qpeek
### 연산 과정
- 공백 큐 생성 / front & rear = - 1
- 원소 삽입(enQueue) / rear += 1
- 원소 반환&삭제(deQueue) / front += 1
- 비어있는가?(isEmpty) / front == queue
- 꽉 찼는가?(isFull) / rear == k-1
### 원형 큐
- 앞서 살펴본 큐의 모습은 front 가 삭제되면 추가적으로 빈 공간을 활용할 수 없게 된다
- 공간적 낭비를 없애기 위해 end와 front가 연결될 수 있는 원형 큐를 구현하면 된다
- 논리적 순환을 이루어 끝에 도달하면 처음 인덱스인 0으로 이동하는 연산을 추가하여 준다(mod연산자 활용)
- 다만 원형 큐를 활용할 시, 데이터를 최대 크기 안에서 덮어 씌울 수 있다는 전재하에 효율적으로 활용할 수 있다
### 우선순위 큐
- 우선순위를 가진 항목들을 저장
- FIFO가 아닌 우선순위 순으로 출력됨
- 적용 분야
  - 시뮬레이션 시스템
  - 네트워크 트래픽 제어
  - 운영체제의 테스크 스케쥴링
#### 배열 활용 우선순위 큐
- 배열에 원소를 삽입하여 적절한 위치에 삽입
- 다만, 재배치 발생하며 시간과 메모리 소비가 큼 (이러한 부분은 트리+배열 구조로 보완 가능)\
### 버퍼(Buffer)
- 데이터를 다른곳에 전송하는 동안 일시적으로 저장하는 메모리 영역
- 일반적으로 입출력 / 네트워크와 관련된 기능에서 활용됨
- 순서대로 출력되어야 하므로 FIFO방식인 큐가 활용되어야 한다

### BFS(너비 우선 탐색)
- 깊이 탐색과 다르게 반복 과정을 거쳐 탐색을 시행한다
- 시작점의 인접 정점들을 모두 방문 후, 거리순으로 인접한 정점들을 탐색(한쪽으로가 아닌 전체를 돌아간다)
- 방문 후 차례로 다시 탐색을 시작해야 하므로 큐를 활용함
```python
n = input()
def BFS(G,v):
    visited = [0] * n+1
    queue = []
    queue.append(v) 
    while queue:
        t = queue.pop(0)
        if not visited[t]:
            visited[t] = True
            visited(t)
            for i in G[t] :
                if not visited[i]:
                    queue.append(i)
```
#### 탐색 종류에 따른 알고리즘 선택
- 빠짐없이 / 중복 없이 = 둘다
- 최단거리 = 둘다 가능 (but BFS가 좀더)
- 경로의 수 = DFS
- 확산(출발이 여러곳) = BFS