'''
1 = 1
11 = 2
111 = 3 (1/1/1 11/1 1/11)
1111 = 5 (1/1/1/1 1/1/11 1/11/1 11/1/1 11/11) (2*2 + 1, a = 2+1, b= 2)
11111 = 9 (3*2 + 2) 8 (5 + 11/1/1/1 11/1/11 11/11/1)
즉, 새로 앞에 붙는 친구가 1또는 2이면 제일 앞이 1개짜리 인 친구들 * 2 + 2개짜리 갯수들
만약 0이라면? 0은 앞의 숫자와 별개가 될 수 없다 = 즉, 한몸으로 평가해야 한다

반대로 
4 = 1개
14 = 2개 1/4 14/ (14,1이 되면 *2) (2*1 + 0) (1,1)
314 = 3/1/4 3/14 (2개) (1+1) (2,0)
2014 = 20/1/4 20/14 (0,2)
32014 = 3/20/1/4 3/20/14 (0*2 + 2) (a=0+2,b = 0)
114 = 1/1/4 11/4 1/14 3개 (2*1 + 1) (1+1,1)
5114 = 5/1/1/4 5/11/4 5/1/14 (2+1)(3,0)
25114 = 2/5/1/1/4 2/5/11/4 2/5/1/14 25 /1/1/4 25/11/4 25/1/14 (2*3+1)
'''

# 1,2 일 경우 a*2+b (a = a+b, b=a)/ 아닌경우, a+b(a+b, 0) /
# 0일 경우, 앞으로 하나 더 진행(하나로 취급) (a=0, b=전부) 
# 아닌 경우 , 26이상이거나 / 


def DP(num):
    limit = len(num)
    if limit == 1:
        if num == '0':
            return (0,0,0)
        return (1,0,0)
    s = 1
    result = (1,1,0)
    if int(num[s-1]) == 0:
        if not(int(num[s]) == 1 or int(num[s]) == 2):
            return (0,0,0)
        s += 1
    while s < limit: 
        target = int(num[s])
        if target == 1: # 1~9 모든 조건에 성립
            t,a,b = result
            t = 2*a + b
            result = (t, a+b, a)
        elif target == 2 and 1<= int(num[s-1]) <= 6: # 21 ~ 26 일때만 작동
            t,a,b = result
            t = 2*a + b
            result = (t, a+b, a)
        elif target == 0:
            s += 1
            # 10, 20 이 아닌 경우, 성립하지 않음 즉, 0
            if s == limit: # 0으로 시작하는 암호일 경우 성립 안함
                return (0,0,0)
            if not(num[s] == '1' or num[s] == '2'):
                return (0,0,0)
            t,a,b = result 
            result = (t,0,t)
        else:
            t,a,b = result
            result = (t,t,0)
        s += 1
        # print(result)
    return result

n = input()
n = n[::-1]
t,a,b = DP(n)
print(t%1000000)

# 220122 2/20/1/2/2 2/20/12/2 