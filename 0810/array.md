## 2차원 배열
- 1차원 배열을 묶어둔 배열
- 차원에 따라 index를 선언할 수 있다.
- 2차원 배열 받는 법
  ```
   n = int(input)
   arr = [list(map(int,input().split())) for _ in range (n)]
   ```
- 리스트 안에 리스트 받는 걸 반복문으로 받을 수 있다

- 전치 행렬
  - 대각선을 기준으로 위치를 바꾸는 행렬
  - 열, 행을 바꾸면 쉽게 바꿀 수 있다.

- 부분 집합
  - 부분 집합은 2*n 개가 생성됨
  - 부분 집합들로 배열을 만들면 2차원 배열이 됨
- 비트 연산자
  - & : 비트 단위로 and 연산
  - | : 비트 단위로 or 연산
  - << : 비트를 왼쪽 이동
  - ">>" : 비트 오른쪽 이동

#### 검색 
  - 원하는 항목을 찾는 작업
  - 순차 검색 / 이진 검색 / 해쉬
  - 순차 검색
    - 일렬로 순서대로 검색
    - 간단, 직관
    - 다만, 효율이 좋지 않음
    - 정렬 / 비정렬에 따라 다르다
    - 비정렬시 그냥 하나씩 찾는다
    - 정렬시 만약 대상보다 크다면 중지 (없다는 것이므로)
  - 이진 검색
    - 키 값과 비교하여 다음 검색 위치를 결정 (탐색 길이가 반으로 줄어든다)
    - 자료가 정렬되어야 한다
    - 중앙에서 탐색 시작 / 비교 / 크면 왼쪽, 작으면 오늘쪽
    - 찾을때까지 위의 줄 반복 
    - 추가로 삽입 및 삭제 발생시 배열의 정렬로 유지하는 작업을 추가해보자
#### 인덱스
- 테이블에 대한 동작 속도를 높여주는 자료구조
- 키 필드만 가지고 있기에 탐색 속도가 빨라진다
#### 선택 정렬
- 주어진 자료들 중 가장 작은 원소부터 차례대로 선택, 후 자리 교환
- 최소값을 찾는다 / 제일 앞과 교환 / 나머지 대상을 반복
- 시간 복잡도 : O(n^2)
- 이때 인덱스를 활용하여 빠르게 정렬
```python
def selectionSort (a,N):
  for i in range(N-1) : # 이 반복 횟수를 조절함으로써 k번째 작은 수를 찾아낼 수 있다.
    minIdx = i
    for j in range(i+1, N):
      if a[minIdx] > a[j]:
        minIdx = j
    ## 중간에 if문과 같은 추가적인 과정은 오히려 메모리 손해
    a[i], a[minIdx] = a[minIdx], a[i]
```
- 다양한 2차원 배열에 대해 배치 형태에 따라 각자의 규칙을 찾고, 그걸 인덱스에 활용할 수 있으면 좋다


#### 비트 연산자
- 에서 비트의 진행 방향을 매우 주의해서 공부해보자

#### 