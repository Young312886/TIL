# 시스템 구조와 프로그램 처리
## 시스템 구조

### computer & I/O Device 
- 간단한 외부 부품과 컴퓨터 부품의 설명
- 각각의 device들은 각각의 controller가 존재, 기능을 조절하게 된다
- 결국, 하나의 디바이스, 메모리 또한 하나의 장치이므로 각각 컴퓨터의 역할을 할 수 있는 부품들이 존재


#### CPU
  - 는 memory와의 통신을 통해 일을 처리
  - 만약, 하나의 프로그램이 무한 루프가 존재할 경우, timer를 통해 특정 프로그램이 cpu를 독점하는 것을 방지 (timer interrupt)
  - 
- 이러한 운동 정보를 저장하는 곳은 local buffer
  - CPU와 device간의 속도 차이 조절 역할
- mode bit
    - cpu에 실행되는 프로그램이 OS 인지 프로그램인지의 여부 저장
- register
  - Memory 보다 빠른 저장장소
- interrupt line
  - 현재 실행되는 프로그램에 대한 인터럽트 저장소
  - 이후 최우선 적으로 고려하게 된다
#### Mode Bit
- 현재 CPU에서 실행중인 프로세스에 관한 정보가 저장되는 장소
- 이를 기반으로 접근할 수 있는 구역에 제한을 주게 된다
- 0일 경우, OS(특권 명령 부여) / 외에는 사용자 프로그램이다
#### Timer
- 특정 프로그램이 CPU의 제어권을 독점하지 않도록 하는 장치
- 현재 시간 계산을 위해 사용
- 시간 초과시 인터럽트 발생 
#### Device Controller
- I/O 장치 관리 하는 작은 CPU
- local buffer 가짐
- 제어를 위한 register 또한 존재
- device driver는 이를 구동하는 OS를 명명한다
#### 입출력의 수행
- 입출력 명령은 특권 명령으로, OS를 반드시 거치게 된다
- 사용자가 사용하기 위해선, 시스템콜(system call)을 하게 된다
- Trap을 사용하여 인터럽트를 걸어주고, 올바른 요청일 경우, I/O를 호출
- 결론적으로 I/O를 하기 위해선 총 2번의 인터럽트가 걸리게 된다(시작 / 끝)
#### DMA controller
- 앞선 존재하고 있는 너무 많은 다양한 인터럽트가 발생 가능
- 따라서 I/O 장치들의 인터럽트를 중간에서 차단 (block 단위로 interrupt 합체)
- memory에 직접 데이터를 올림
- 이를 통해 CPU가 받는 인터럽트는 업무당 한번만 발생

### 동기식과 비동기식
- 동기식 (synchronous)
  - 입출력이 완료된 이후에야 제어가 사용자 프로그램으로 전환됨
  - 요청 -> 데이터 -> 이후 다른 작업
  - 다만, 기본적인 순서로 실행한다면 CPU가 낭비되는 현상 발생
  - 요청 -> 다른 프로그램으로 CPU 넘겨줌 (CPU 낭비 감소)
- 비동기식
  - 입출력이 완료되지 않아도 다른 작업을 진행
  - kernel이 요청 외의 작업을 알아서 수행중에 있게 된다

### 저장장치 계층 구조
- Register -> Cache -> Main  // -> Magnetic Disk -> Optical -> Magnetic Tape
- 위가 속도가 빠르고 용량이 작음
- 위 3개는 Primary이며, 휘발성이다. CPU가 접근이 가능함 (Byte 단위 접근이 가능한가)

### 메모리 구조에 관하여
- code - data - stack으로 구성
- 모든 프로그램은 함수의 형태로 구성되어 있다
- virtual 주소가 physical 주소로 전환되어 읽히게 된다
#### 커널 주소 공간의 내용
- 커널 또한 하나의 프로그램이므로 메모리 공간을 차지하게 된다
- code : 처리 코드, 관리 코드, 서비스 제공관련 코드
- data : 운영체제들에 대한 자료구조 정보 등등 / 프로그램들의 정보 등 (PCB)
- stack : 해당 커널들의 스택