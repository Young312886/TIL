# 프로세스

## 생성
- 부모와 자식이 존재, 부모가 자식을 생성
- 즉, 트리 구조이다
- 생성을 위해선 자원을 필요로 함
- 경우에 따라 자원을 공유하긴 하는 경우도 있지만, 일반적으로 공유하지 않음
- 실행 시, 대기할 수도 있고, 공존할수도 있고

### 복제 생성 (Copy-on-write)
- 부모의 주소를 자식이 복제
- 유닉스에서
- fork()를 통해 생성 (시스템 콜을 통해)
- 덮어 씌우는 것인 exec() 를 통해 새로운 프로그램을 메모리에 올림
## 종료
- 프로세스 마지막 명령에 exit이 존재
- 자식은 output data 를 부모에게 전달
- 만약, 부모가 자식을 종료시킨다면(abort)
  - 자식이 할당 자원치를 넘기거나
  - 할당 태스크가 더 필요하지 않거나
  - 부모가 exit 하는 경우 (단계적 종료를 위해)
## fork()
```c
// 자식 프로세스는 fork 이후의 부분만을 실행하게 됨
// 따라서, 자식과 부모는 다른 일을 할 수 도 있고, 다른 결과물을 내놓을 수 있다
int main()
{
    int pid;
    pid = fork();
    if (pid==0) 
        printf('\n Hello, child\n');
    else if (pid > 0)
        printf('\n Hello, parnet');
}
```
## exec()
```c
// date라는 프로그램을 자식에 작동시키는 코드(덮어씌우게 된다)
// exec을 실행하게 되면 이전의 status로 돌아갈 수 없다
// exec가 실행되면 이후에 작성된 프로그램은 실행되지 않는다(완전히 대체되기 때문)
int main()
{
    int pid;
    pid = fork();
    if (pid==0) 
        printf('\n Hello, child! Now run date\n');
        execlp('/bin/date', '/bin/date', (char *)0);
    else if (pid > 0)
        printf('\n Hello, parnet');
}
```
## wait()
- wait 시스템 콜은, 부모 프로세스를 block하게 된다
- 이후 자식 프로세스가 다 돌아가게 되면, 이후에 ready로 전환

## exit()
- 자발적 종료시 실행되는 시스템 콜
- 마지막에 컴파일러가 넣어주기도 함
- 비자발적 종료 또한 존재
  - 부모가 자식을 죽이거나 (강제 종료)
  - 키보드로 kill, break 선언
  - 부모가 종료되는 경우, 자식은 먼저 종료됨
### 프로세스 간 협력
- 독립적 프로세스(기본적)
  - 각자 주소 공간을 가지고 수행되므로 상호 영향을 주지는 못함
- 협력 프로세스
  - 협력 메커니즘을 통해 다른 프로세스 수행에 영향을 줄 수 있다
  - 협력 메커니즘
    - message passing
      - 커널을 통해 메시지 전달
      - 공유 변수를 사용하지 않는 통신 시스템
      - Direct Communication / Indirect
      - 직접 명시 / 간접 전달(port사용)
      - 둘 다 커널을 사용한다는 것은 동일
    - shared memory
      - 일부 주소 공간을 공유하는 메커니즘
      - 물리적 메모리 공간을 공유
      - 스레드는 엄밀히 말하면 협력으로 보기는 어렵지만, 주소공간을 공유하므로 협력이 진행된다
