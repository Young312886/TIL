## 알고리즘 
### APS(Advanced Planning & Schedueling)
- 시스템 생산 최적화 프로그램
  
#### 좋은 알고리즘이란?
- 정확성 : 정확한가? 
- 작업량 : 적은 연산을 사용하는가?
- 메모리 사용량 : 적은 메모리를 사용하는가?
- 단순성 : 단순한가?
- 최적성 : 개선 여지가 있는가?

알고리즘에는 정답 자체는 없다. 다만 덜 좋은 알고리즘이 있을 뿐

문법과 자료구조를 공부하면서 컴퓨터 구조를 공부한다면 추가적인, 이해하기 어려운 효율성을 좀 더 찾아낼 수 있다.
#### 시간 복잡도
- 빅오 표기법 O(n)

#### 자료 구조
##### 배열
- 일정한 자료형의 변수들을 열거하여 사용하는 것
- 다수의 변수로는 하기 어려운 작업을 배열을 통해 쉽게 할 수 있다(ex, 반복문)

### 정렬
#### 버블 정렬
- 인접한 두개의 원소를 비교하여 계속해서 교환하는 방식
- 첫 원소가 마지막 원소까지의 비교와 교환을 거듭한다
- 시간 복잡도 = O(n^2)

#### 카운팅 정렬
- 집합에 항목이 각 몇개씩 있는지 세는 작업을 통해 정렬
- 다만, 정수나 정수로 표현 가능한 자료에만 사용 가능
- 가장 큰 정수를 알아야 충분한 공간 할당 가능
- 시간복잡도 = O(n+k)
- count[]를 하나 만들어서 index에 +=1 해준다.
- 길이는 최대 100만 까지는 가능(통상)
- 여태까지의 합과 그 중간의 합 (누적합) 또한 이것의 결과물로 쉽게 계산 가능
- 이후, 안정정렬 시행. (순서를 유지하면서 크기별로 배열 가능)
- 안정정렬 방법 : 갯수에 하나씩 빼고 그 값을 index로 찾아서 넣어준다 (역순으로)

### 완전 검색
- 모든 경우의 수를 확인하는 기법
- brute-force 또는 generate and test 기법
- 순열, 조합, 부분집합 등에 자주 사용
- 경우의 수가 적을 경우 유용

### 탐욕 알고리즘 (greed search)
- 최적에 가까운 방향으로 진행
- 그것이 완벽에 가깝다고는 말할 수는 없는 상황
1. 해 선택 : 최적해를 구한뒤, 부분해 집합에 추가
2. 실행 가능성 검사 : 위반하지 않는가?
3. 해검사 : 전체 완성 되었는가? 아니면 다시