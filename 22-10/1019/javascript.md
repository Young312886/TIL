# 가장 인기있는 웹 조작 언어, 자바스크립트
- 따라서 웹 브라우저와 관련된 다양한 단어들에 익숙해져야 한다
- 웹을 정적인 페이지에서 동적으로 바꿔줄 언어가 필요
- Script 언어 개발
## 역사
- Netscape 에서의 Script 언어가 개발 시작됨
- Mocha, LiveScript, JavaScript 순으로 이름이 변경됨
- Java 의 명성에 기대보기 위해 이름을 변경
- IE는 netscape 를 배끼면서 JScript 라는 복제언어를 제작
#### 1996 -2000
- 위의 상황에서 표준안이 필요하게 됨
- ECMA 에서 표준안 출시 - ECMAScript
- MS에서 IE의 점유율을 급속도로 상승시킴(95%까지)
- 이후, 이 표준안 지키지 않겠다 선언
#### 2001 - 2004
- Netscape 는 망하고, 개발자가 나와서 FireFox를 개발
- Mozilla 재단이 출범
- 당시 더욱 다양한 웹브라우저가 출시되기 시작, 개발자들은 죽을 맛
##### Jquery 라이브러리
- 브라우저 엔진에 맞춰 스크립트가 변환되도록 해줌
- 다만, 이후 표준화 되면서 웹브라우저에 javascript 해석하는 엔진이 탑재
- 더이상 필요가 없어짐
#### 2008 ~
- Chrome의 등장과 v8엔진을 통한 빠른 속도를 보여줌
- Chrome의 성능과 점유율에 다 항복하고 표준안을 만들자고 제안
- 2015, ECMAScript6 표준안 제정(ES6)

## JavaScript
### script 태그
- script 태그 안에선 js가 자동으로 인식, 작동된다
- 자동완성도 당연히 되고
- 원래는 ; 으로 구문 구분을 했지만, ASI 가 자동으로 입력해준다
- 블럭 구분은 {}을 사용해 코드블럭을 구분
- 주석은 //
- 카멜케이스는 변수,객체,함수에 / 파스칼케이스는 클래스,생성자 / 대문자스네이크는 상수에
- 변수 선언 키워드 : let, const, var
- 변수
  - 변수 할당 단계
  - 1. 선언 = 변수를 생성
  - 2. 할당 = 변수에 값을 저장
  - 3. 초기화 = 선언된 변수에 처음으로 값을 저장하는 시점
- block scope = name space 다른곳과 구별되는 지역, {}를 기준으로 구분됨
- 변수 선언
  - let
    - 재할당 가능 & 재선언 불가능
  - const
    - 읽기 전용 
    - 재할당, 재선언 불가능
    - 선언 시 반드시 초기값을 설정해 줘야 함
  - var
    - 그냥 쓰지 말자
    - 재할당, 재선언 모두 가능
    - ES6이전에 사용되던 키워드
    - 호이스팅으로 인한 문제 발생 가능
    - 함수 스코프를 가짐
    - 만약 위에 let,const 선언안하면 var로 생성되므로 조심
    - 호이스팅
      - 변수 선언 이전에 참조 할 수 있는 현상
      - undefined가 발생
- 데이터 타입
- 원시 타입 // 참조 타입 이 존재
- 원시 타입
    1. number : 정수 또는 실수형
        - NaN = 숫자가 아님
        - 숫자로 읽을수 없거나 계산이 안되는 경우
    2. String : 문자열
      - 다만 문자열 연산은 안됨
      - escape sequence로 줄바꿈
      - Template Literal을 사용하면 줄바꿈에 변수 삽입도 가능(fsting처럼, ${}), ``을 사용해서 적으면 됨
    3. Empty value
       - null 과 undefined 가 존재
       - null
         - 값이 의도적으로 없음을 표현할 때 사용
       - undefiend
         - 직접 값을 할동하지 않았을 때, 자동으로 부여 
    4. Boolean
       - 참거짓, 다만 소문자로 작성
       - 자동 형변환 적용됨 
    5. 연산자
     1. 할당 연산자 (+=, -= *= ++ -- (1씩 증가 감소))
     2. 비교 연산자 (< > = )
     3. 동등 연산자 (==) boolean반환, 암묵적으로 타입 변환함 / 다만, 예상치 못한 결과가 발생할 수 있으므로 특수 상황 제외 사용 안함
     4. 일치 연산자 (===) 값과 타입이 모두 일치할 경우 (타입 변환 안함)
     5. 논리 연산자 (&& || !)
     6. 삼항 연산자 (true ? A : B) 맞으면 앞의것을 아니면 뒤의것을 반환
    6. 조건문
       - if () {} else if () {} else {} 
    7. switch statement
       - 조건이 많을 경우, 유지보수시에 스위치가 더 좋음 
       - swtich (expression) { case A : {} case B : {} default : {}}
       - break 문을 넣어줘서 모두 출력되는 현상을 방지 
    8. 반복문
       - while (조건) {}
       - for (초기; 조건; 증감) {}
       - for (variable in objects) {} (순회함, 다만 배열은 순서대로 안갈수도 있음)
       - for (variable of objects) {} (순서대로 순회)
       - for in 은 속성의 이름(object가 딱 활용 가능)을, for of 는 속성 값을 반복
#### 문법
  1. 함수
     - 함수 선언식 : function name(params) {}
     - 함수 표현식 : const name = function () {} 식으로도 익명 함수로도 가능
     - 파이썬과 다르게 매개변수와 인자간의 개수 차이는 오류가 발생하지 않는다
     - 할당 값이 없으면 undefined로 나오게 된다
     - 가변인자 대신 spread syntax가 존재 (...)
       - 정해지지 않은 인자들을 배열식으로 받아옴
     - 선언식과 표현식 차이
       - 선언식은 호이스팅이 발생(코드 최상단에서 작동)
       - 따라서 함수 선언 이전에 호출해도 작동
       - 반면 표현식은 변수로 평가 받아 변수의 scope를 따라가므로 호이스팅이 발생하지는 않음
  2. 화살표 함수
     - 함수를 비교적 간결하게 정의할 수 있는 문법
    ```javascript
        const greeting = function (name) {
            return 'HI ${name}'
        }
        <!-- 1단계 축소 -->
        const greeting = (name) => {
            return 'Hi ${name}'
        }
        <!-- 3단계 축소 -->
        const greeting = name => 'Hi $(name)'
    ```
     - 위의 함수가 아래의 함수로 축소 된다
     - 다만 명확성과 일관성을 위해 인자의 ()는 포함하도록 하자

   3. 즉시 실행 함수
     - 선언과 동시에 실행되는 함수
     - 선언 끝에 ()를 추가하여 인자를 넘겨준다
     - 다만 재호출이 불가능


### 배열과 object(객체)
- 파이썬의 리스트와 딕셔너리
#### 배열
- 키와 속성들을 담고 있는 참조 타입의 객체
- 순서 보장
- [] 로 생성, 0 에서 시작, 양의 정수 인덱스
- array.length 로 길이 접근 가능
- 값이 없으면 undefined가 출력 됨
##### 메서드
- reverse
- push / pop
- unshifth / shift : 왼쪽에 빼거나 넣기
- includes : 포함되어 있는가?
- indexOf : 특정 값의 인덱스 반환, 없으면 -1
- join(연결)

- 배열을 순회하며 특정 로직을 수행하는 메서드
- 호출 시 인자로 callback 함수를 받는 것이 특징
- callback 함수 : 함수 내부에 실행될 목적으로 인자로 넘겨받는 함수

- forEach : array.forEach((element, index, array) => {})
  - => {} 라는 함수를 각각의 배열의 요소에 적용시키자
  - 밖의 함수를 하나씩 넣어 가면서 줄여가는 방법이다
- map : 콜백함수의 반환값을 요소로 하는 배열 반환
  - forEach + 배열 반환이다
  - return이 있으므로 앞에 받는 변수 설정 필요
- filter : 함수에 true인 친구들만 배열 반환
- reduce : 함수를 적용하여 하나의 값을 반환
  - array.reduce ((acc, element, index, arry)) => {}, initalvalue)
  - 매개변수
    - acc : 반환값이 누적되는 변수
    - initalvalue : 최초 호출시 acc값에 할당되는 값 없을 경우 첫번째 인자값
    - 빈 배열일 경우 오류가 날 수 있으므로 initalValue적어주도록 하자
- find : 반환 값이 참이면 그 첫번째 요소를 반환 없으면 undefined
- some : 요소 중 하나라도 판별을 통화하면 참을 반환 (빈배열은 무조건 false)
- every : some과 반대로 모든 요소가 판별을 통과해야 한다 (빈배열은 무조건 true)

#### 객체
- 속성의 집합, key 와 value의 쌍이다
- key는 문자열 타입만 가능
- value는 모든 타입 가능
- 접근은 . 또는 [] 로 접근 가능
1. 속성명 축약
   - 만약 key와 value가 동일하다면, 생략 가능
   - 내용물은 동일
2. 메서드 축약
   - 메서드 선언시 function 키워드 생략가능
3. 계산된 속성
   - 객체 정의시 key의 이름을 표현식으로 이용하여 동적으로 생성 가능
   - const object = { [ key ] : ()}
   - 위의 선언 값을 바꿔버리면 key의 값도 변화
4. 구조 분해 할당
   - 만약 변수와 key 이름이 동일하다면 찾아서 할당하지 않아도 쉽게 할당시킬 수 있다.
   - const name = userInfo.name
   - const { name } = userInfo
   - 위의 두 코드는 동일한 작업을 실행함
5. spread Syntac
   - 객체 내부에서 다른 객체를 복사해 오기도 한다
   - 얕은 복사로 활용 가능

##### json 변환
- const value = JSON.stringfy(object)
- 역변환
- const newone = JSON.parse(value)