## 트리
- 비선형 자료 구조
- 원소들 간의 1:n의 관계를 가지는 계층형 구조
- 아래로 갈수록 확장된다
- 한개 이상의 노드로 이루어진 유한집합
- 트리의 용어정리
  - node = 트리의 원소
  - 최상위 노드 = 루트(loot)
  - 나머지 노드들은 분리집합으로 분리될 수 있다(subtree)
  - 최하단의 노드 = leaf
  - 간선(edge) = 노드를 연결하는 선
  - 형제노드 = 같은 부모를 가진 자식 노드들
  - 조상 노드 = 루트 노드까지 이르는 경로의 모든 노드들
  - 서브트리(subtree) = 부모의 간선을 끊었을 때 생성되는 트리
  - 자손 노드 = 서브트리 안의 하위 노드들
  - 차수 = 노드에 연결된 자식 노드의 수
  - 트리의 차수 = 차수 중에 최대값
  - 단말 노드(=leafnode) = 차수가 0인 노드
  - 높이 = 루트에서 노드에 이르는 간선의 수(이건 상대적인 값이다, 시작이 0일수도, 1일수도)
  - 트리의 높이 = 높이의 최대값
## 이진트리
- 모든 노드들이 2개의 서브트리를 갖는 트리
- 모든 노드가 최대 2개의 자식노드를 갖게 된다
- 이진트리의 종류 (종류별로 저장과 해독법이 다르다)
  - 포화 이진 트리(FUll binary)
    - 모든 노드가 다 차 있는 이진트리
    - 높이가 h, 노드 갯수가 2^(h+1) -1 개
    - 루트를 1번, 높이 하나씩 증가, 왼쪽에서 오른쪽으로 차례대로 번호 부여
  - 완전 이진 트리(Complete binary)
    - 위에는 포화이고, 리프들이 몇개 없는 이진트리
    - 1에서 n번까지는 빈자리가 없다
  - 편향 이진 트리(Skewed binary)
    - 한쪽 방향의 자식노드만 존재
    - 선형 자료 구조와 차이가 없어 보임
    - 아래로 번호 하나씩 증가
- 이진트리의 순회(traversal)
  - 노드를 중복되지 않게 방문하는 방법
  - 3가지 방법
    - 전위 순회(preorder,VLR)
      - 부모 방문 후, 자식을 좌,우 순서로
      - 부모 방문 => 자식 여부 확인 => 있으면 왼쪽 부터 방문(방문시 부모로 돌아감) => 없으면 오른쪽(방문시 부모됨) => 자식 없으면 부모로 돌아감
    - 중위 순회(inorder,LVR)
      - 왼쪽 자식, 부모, 오른쪽 자식
      - 현재 부모의 왼쪽 으로 이동 => 다 돌면 부모 방문 처리 => 오른쪽 서브 트리로 이동
    - 후위 순회(postorder,LRV)
      - 자식 좌, 우 이후 부모
      - 왼쪽 서브트리 이동 => 오른쪽 서브트리 이동 => 부모 방문
- 이진트리 표현(번호)
  - 다만 이 방식은 완전 이진 트리의 경우에만 가능
  - 노드번호를 왼쪽에서 오른쪽으로, 깊이 순으로
  - 번호 위치의 배열에 할당
  - 부모 노드 번호는 i//2 에 위치
  - 2*i , 2 * i + 1 가 각각의 자식 노드 번호
  - 위의 번호들을 바탕으로 이후 움직일 수 있다
  - 또는, 배열을 2개 더 만들고,
  - 간선의 갯수+1 만큼 부모 위치에 자식의 번호를 저장하는 과정을 진행
  - 반대로 자식을 기준으로 부모의 번호를 저장하는 방식도 있다
  - *추가로 연결리스트로도 가능하다*
## 이진 탐색 트리
- 탐색 작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 유일한 키를 갖는다
- 왼 < 루트 < 오른 순
- 중위순회 시 오름차순으로 정렬된 값을 얻을 수 있다
- 탐색 연산시, 크기 비교를 통해 원하는 노드 탐색 가능
- 삽입연산
  - 탐색 이후, 탐색 실패가 되는 위치가 바로 삽입 위치 이다
- 탐색, 삽입, 삭제는 트리의 높이 만큼 걸린다 = O(h) 평균 O(log n)
### 최대 힙
- 최대 힙을 통해 삽입과 출력을 구현할 수 있다
  - 최대힙 (최소힙도 동일, 다만 순서가 바뀔 뿐)
  ```python
  def enq(n):
    global last
    last += 1
    heap[last] = n

    c = last
    p = c // 2
    while p and heap[p] < heap[c]:
        heap[p], heap[c] = heap[c], heap[p]
        c = p
        p = c // 2
    ```
    - 선택정렬과 유사하게 위치간 교환을 이뤄진다(부모와 자녀간)
    - 삭제의 경우, 루트의 삭제 이후, 마지막 노드(last)의 친구를 루트로 변경, 이후 자리 변경 실시
    - 이 경우, 자녀가 2개면 자녀간의 비교도 진행해줘야 한다
    ``` python
    while c <= last:
        if c+1 <= last and heap[c] <heap[c+1]:
            c += 1
        if heap[p] < heap[c]:
            heap[p], heap[c] = heap[c], heap[p]
            p = c
            c = p // 2
        else:
            break
    ```
    ### 영역 나누기
    